# 软件复杂性三定律（或者：为什么软件工程师总是脾气暴躁）

我认为，由于三个基本定律，大多数软件工程师（特别是那些从事基础设施系统工作的工程师）注定会陷入不必要的复杂性中。

# 软件复杂性第一定律：随着时间的推移，设计良好的系统将退化为设计糟糕的系统

我们从一个固执己见的定义开始：一个设计良好的系统是一个很容易随着时间的推移而改变的系统；设计糟糕的系统是很难改变的。假设系统 X 设计良好。有人出现并根据定义快速而轻松地将其更改为不同的系统 X’。现在 X’ 要么继续精心设计；要么在这种情况下，它可以快速轻松地再次修改为不同的系统 X”；否则它将进入设计不良的状态，因此难以修改。例如，考虑一个设计良好的数据库，它在干净的存储引擎 API 背后使用 RocksDB；然后有人出现并向其添加 getLevelSize 调用；现在，数据库无法再轻松修改以在非 LSM 存储引擎上工作。由此可见，一个设计良好的系统是一种不稳定的、短暂的状态。而一个设计糟糕的系统是一个稳定、持久的状态。因此，野外系统的组合不断退化，导致设计不佳。代码的二阶导数在野外总是负的：代码更改的速度随着时间的推移而下降。根据这条定律，大多数工程师将在设计糟糕的系统上工作，因为随着时间的推移，大多数系统都会变成设计糟糕的系统。

# 软件复杂性第二定律：复杂性是一条护城河（由 Leaky Abstractions 填充）。

设计一个好的抽象是在为应用程序提供实用性和隐藏有关实现的细节之间的微妙舞蹈。当系统相互竞争市场份额时，精致性就会被抛之脑后，设计人员通常会为应用程序提供它想要的一切。这具有通过吸引应用程序开发人员来增加市场份额的双重效果；同时使得竞争系统难以在幕后替代不同的实现。地球上一些最成功的系统拥有几乎不可能以任何其他方式实现的 API（我想到了 ZooKeeper 强于线性化的一致性和基于 TCP/IP 的临时节点语义；Kafka 的幂等产生语义也是如此）。根据这条定律，大多数工程师将在设计糟糕的系统上工作，因为大多数成功/流行的系统都是设计糟糕的系统。

# 软件复杂性第三定律：软件复杂性没有基本上限。

在由大量人员随着时间的推移构建的现实世界系统中，复杂性仅受人类创造力的限制。系统的形状是由数十名开发人员的能力、理念和特质决定的，每个开发人员都在一组复杂的真实和感知的激励下工作。例如，为什么这个复制数据库使用自己的八卦层来检测故障而不是依赖 Kubernetes？也许 TL 爱丽丝和开发人员鲍勃都同意基于八卦的故障检测是正确的选择；但一旦 Bob 编写了代码，Alice 就意识到在容器化环境中这是错误的方法；但经理查理已经为鲍勃写了促销文档，而爱丽丝不想冒阻止公关的政治风险。或者，该系统最初是由 Bob 为非容器化环境设计的，在这种环境中，八卦实际上是一个不错的选择。或者鲍勃的博士学位可能是基于八卦的协议。也许爱丽丝随后将成员资格和领导者选举分为不同的层，以避免与鲍勃和查理对抗，这就是为什么你的系统现在有两个具有有趣交互的层。每个现有系统都是由数十个您可能不认识的人对您发起的 DoS 攻击；一座布满陷阱的宫殿，里面充满了滴答作响的复杂定时炸弹，在你参与之前几年就埋下了。根据这条定律，在设计不良的系统上工作的工程师将尤其遭受损失，因为设计不良的系统具有无限的复杂性。

对于这种状况，我们能做些什么呢？在我的职业生涯中，我采取了一种特殊的方法，即从零开始建立新系统（在它们屈服于三大法则之前）。
