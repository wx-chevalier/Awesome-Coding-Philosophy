# 复杂性定义

复杂性是指软件系统结构使其难以理解和修改的特性。它可以表现为多种形式：

- 难以理解代码的工作原理
- 实现小改动需要大量精力
- 不清楚需要修改系统的哪些部分
- 修复错误时容易引入新的问题

简单来说，如果一个软件系统难以理解和修改，那它就是复杂的；反之，如果容易理解和修改，那它就是简单的。在复杂的系统中，即使是小改动也需要大量工作；而在简单的系统中，可以用较少的精力实现更大的改进。

值得注意的是，复杂性并不一定与系统的规模或功能数量直接相关。虽然大型系统通常都很复杂，但小型系统也可能非常复杂。复杂性主要取决于开发者经常接触的代码部分。如果系统中有些非常复杂的部分，但几乎不需要修改，那么它们对整体复杂性的影响就不大。

我们可以用一个简单的公式来描述这个概念：

$$
C=\sum_{p} c_{p} t_{p}
$$

这里，C 表示系统的总体复杂度，cp 表示每个部分的复杂度，tp 表示开发人员在该部分上花费的时间。这意味着，如果我们能把复杂的部分隔离在很少被访问的地方，效果几乎和完全消除复杂性一样好。

# 业务复杂度与技术复杂度

复杂度可以分为两种主要类型：业务复杂度和技术复杂度。

业务复杂度源于客户的业务需求。随着需求规模的增大，这种复杂度通常会增加。这是我们讨论复杂性时的核心问题。

技术复杂度则来自系统的质量属性要求，如安全性、高性能、高并发、高可用性等。这些要求给软件设计带来了巨大挑战，而且这些因素之间可能相互矛盾或影响。

更棘手的是，业务复杂度和技术复杂度并不是完全独立的。它们混合在一起时，会产生难以预料和控制的复杂性，就像化学反应一样。

![技术复杂度与业务复杂度融合](https://s3.ax1x.com/2021/02/02/yn7XWV.png)

让我们深入了解一下技术复杂度：

- 安全性要求：需要添加访问控制、加密、认证和授权等机制，这会增加系统的间接层，影响性能并提高代码复杂度。
- 高扩展性和弹性：要求系统设计必须是无状态的。
- 用户体验优化：可能需要增加后台任务来处理数据，如预热和预缓存，以提高实时接口的响应速度。

这些技术需求之间可能相互冲突。例如，在复杂的高响应要求的业务场景（如下单、秒杀）中，可能需要将同步请求拆分为多个异步步骤，并使用消息中间件来处理。这种做法虽然提高了系统的响应能力，但也增加了架构复杂性，给高可用性和数据一致性带来了挑战。

业务复杂度和技术复杂度的结合可能会产生意想不到的复杂性，就像氢气和氯气混合后遇到光会发生爆炸一样。

# Complexity Symptoms | 复杂性的症状

复杂性通常通过以下三种方式表现出来，每种方式都会使开发任务变得更加困难。

## 变更放大（Change amplification）

这是指看似简单的变更需要在多个地方修改代码。让我们用一个网站的例子来说明：

想象一个有多个页面的网站，每个页面都有一个带背景色的横幅。在早期的网站设计中，每个页面都单独指定了横幅颜色，如下图(a)所示。要改变整个网站的横幅颜色，开发者可能需要修改每一个页面，这在拥有数千页面的大型网站中几乎是不可能的。

现代网站通常采用如图(b)所示的方法，将横幅颜色集中在一个地方指定，所有页面都引用这个共享值。这样，只需要一次修改就可以改变整个网站的横幅颜色。

![网站更改示意](https://s3.ax1x.com/2020/11/28/DyAx00.png)

## 认知负荷（Cognitive load）

认知负荷指的是开发者需要了解多少信息才能完成一项任务。高认知负荷意味着开发者需要花更多时间学习必要的信息，也更容易因为遗漏重要信息而犯错。

举个例子：假设有一个 C 语言函数，它分配内存并返回指向该内存的指针，但要求调用者负责释放这块内存。这就增加了使用该函数的开发者的认知负担。如果开发者忘记释放内存，就会导致内存泄漏。如果我们能重新设计系统，让分配内存的模块也负责释放内存，就能减少认知负担。

有些人可能认为可以用代码行数来衡量复杂性，认为代码越少越简单。但这种观点忽视了认知负荷的成本。我见过一些框架，只需几行代码就能写出一个应用，但理解这几行代码的含义却极其困难。有时，使用更多代码行的方法反而更简单，因为它减少了认知负担。

## 未知的未知（Unknown unknowns）

这是指开发者不清楚需要修改哪些代码或需要了解哪些信息才能成功完成任务。

让我们回到之前的网站例子，如图(c)所示。网站使用一个中心变量来确定横幅的背景颜色，看起来很容易更改。但是，一些网页使用了较深的背景色来强调，这个颜色是在各个页面中单独指定的。如果更改了中心的背景色，这些强调色也需要相应调整。然而，开发者可能不知道这一点，或者不清楚哪些页面使用了强调色。这就导致了"未知的未知"问题。

## 总结

在复杂性的三种表现形式中，"未知的未知"是最棘手的：

- 变更放大虽然令人烦恼，但只要清楚需要修改哪些代码，完成更改后系统就能正常工作。
- 高认知负荷会增加更改的成本，但如果知道需要了解哪些信息，仍然可能做出正确的更改。
- 对于未知的未知，开发者不清楚该做什么，也不确定提出的解决方案是否有效。理论上，唯一确定的方法是阅读系统中的每一行代码，这对于任何大型系统来说都是不现实的。更糟糕的是，有些更改可能依赖于从未记录过的微妙设计决策。

因此，良好设计的一个重要目标是使系统变得"显而易见"。在一个显而易见的系统中：

- 开发者可以快速理解现有代码的工作原理
- 容易确定需要进行哪些更改
- 开发者可以轻松猜测需要做什么，并且能确信猜测是正确的

这种设计方法可以有效减少认知负荷和未知的未知，使系统更易于理解和维护。
